MySQL Deployment (mysql-deployment.yaml):
- Creates a single MySQL pod (replicas: 1 for data consistency)
- Uses persistent storage for data durability
- Mounts an init script from ConfigMap
- Exposes port 3306
- Uses secrets for sensitive data

MySQL Service (mysql-deployment.yaml):
- Type: ClusterIP (internal access only)
- Allows other pods in cluster to connect to MySQL using mysql-service hostname
- Exposes port 3306

MySQL PVC (mysql-pvc.yaml):
- PersistentVolumeClaim requests storage for MySQL
- Ensures data persists even if pod restarts

MySQL ConfigMap (mysql-configmap.yaml):
- Contains initialization SQL script
- Creates necessary table on first startup

MySQL Secret (mysql-secret.yaml):
- Stores MySQL root password securely
- Base64 encoded for Kubernetes requirements

URL Shortener Deployment (urlshortener-deployment.yaml):
- Runs 3 replicas for high availability
- Uses your Docker image
- Configures environment variables to connect to MySQL
- Exposes port 5000 (default for Flask)

URL Shortener Service (urlshortener-deployment.yaml):
- Type: LoadBalancer (external access)
- Maps port 80 to container port 5000
- Provides load balancing across the 3 replicas

To deploy these manifests:
- First, make sure your Docker image is built and available:

Each pod shows:
- Flask server running
- Handling POST requests for URL creation
- Handling HEAD requests for redirections
- 200 status codes for successful operations
- 302 status codes for redirections


================================================================================================

# URL Shortener with Kubernetes

A URL shortening service built with Flask and MySQL, deployed on Kubernetes.

## Prerequisites

1. Install the following tools:
   - Docker Desktop
   - Minikube
   - kubectl
   - Python 3.x (for local development)

### Windows Installation
powershell
# Install Chocolatey (Windows package manager)
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

# Install required tools
choco install docker-desktop
choco install minikube
choco install kubernetes-cli


### Linux/WSL Installation
bash
# Install Docker
sudo apt-get update
sudo apt-get install docker.io

# Install Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Install kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl


## Project Setup

1. Clone the repository:
bash
git clone <repository-url>
cd CC-URLShortener


2. Start Minikube:
bash
# Start Minikube with Docker driver
minikube start --driver=docker

# Verify Minikube is running
minikube status


3. Build and deploy the application:
bash
# Point shell to minikube's docker-daemon
eval $(minikube docker-env)

# Build the Docker image
docker build -t urlshortener:latest .

# Apply Kubernetes configurations
kubectl apply -f k8s/mysql-secret.yaml
kubectl apply -f k8s/mysql-pvc.yaml
kubectl apply -f k8s/mysql-configmap.yaml
kubectl apply -f k8s/urlshortener-config.yaml
kubectl apply -f k8s/mysql-deployment.yaml
kubectl apply -f k8s/urlshortener-deployment.yaml

# Verify all pods are running
kubectl get pods -w


4. Access the application:
bash
# Start minikube tunnel (keep this terminal open)
minikube tunnel

#In a new terminal, forward the requests from app port (3307) to the MySQL default port (3306) (keep this terminal open)
kubectl port-forward service/mysql-service 3307:3306

# In a new terminal, get the service URL
kubectl get service urlshortener-service


The application will be available at http://<EXTERNAL-IP> shown in the service output.

## Testing the Application

1. Make the test script executable:
bash
chmod +x test_api.sh
dos2unix test_api.sh


2. Run the test script:
bash
./test_api.sh


This will:
- Create 10 shortened URLs
- Test redirections
- Show load balancing across pods



## Troubleshooting

1. If pods are not starting:
bash
kubectl describe pods


2. If the service is not accessible:
bash
# Check service status
kubectl get services

# Check service endpoints
kubectl get endpoints urlshortener-service


3. To view application logs:

# View URL shortener logs
kubectl logs -l app=urlshortener

# View MySQL logs
kubectl logs -l app=mysql

# Current replica set information
kubectl get hpa urlshortener-hpa

# To monitor cpu tests:
watch -n 2 "kubectl top pods | grep urlshortener"


4. To restart deployments:
bash
kubectl rollout restart deployment urlshortener-deployment
kubectl rollout restart deployment mysql-deployment


## Cleanup

To stop and clean up the project:

bash
# Delete all resources
kubectl delete -f k8s/

# Stop minikube
minikube stop

# Optional: Delete minikube cluster
minikube delete

NOTE:
terminal 1: minikube tunnel
terminal 2: port-forwarding
terminal 3: kubectl get service  OR   api_test   OR   stress_tests
terminal 4: CPU usage monitoring


## Environment Variables

The application uses the following environment variables (configured in ConfigMaps and Secrets):

- MYSQL_HOST: MySQL service hostname
- MYSQL_PORT: MySQL port (default: 3306)
- MYSQL_USER: MySQL username
- MYSQL_PASSWORD: MySQL password (in secret)
- MYSQL_DATABASE: Database name
- FLASK_ENV: Flask environment
